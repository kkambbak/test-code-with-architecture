테스트는 프로그램이 지켜야할 계약 같은 것이다.

테스트가 없는 부분에 대해 "어? 이건 이렇게 바꿔도 되는거 아닌가요?" 라는 부분을 답변없이 수정하고 approve 되었다고 가정했을 때, 만약 이게 테스트가 있었다면??? 진작에 검증이 되었을 것이다.

유지하고 싶은 상태가 있다면 전부 테스트로 작성해라.

Testablility

test double (테스트 대역)

## 테스트에 필요한 개념

### BDD given when then

### 상호작용 테스트
대상 메서드가 실제로 호출이 되었는지 검증

그닥 좋은 방법이 아님. 내부 구현을 어떻게 했는지 감시하기에 캡슐화에 위배됨.
이 객체가 제대로 수행했는지만 확인하면 되는데 구현방법에 집착?

### 상태 검증 vs 행위기반검증
어떤 값을 시스템에 넣었을 때

나오는 결과값을 기대값과 비교
vs
협력객체에 어떤 메서드를 실행하는가

### 테스트 픽스쳐
@beforeEach 같은

### Test double
테스트 대역
가짜 객체

*Dummy* 일을 시켜도 아무 동작을 안하는 객체
*Fake* Local이나 테스트에 사용하기 위해 만들어진 가짜 객체. 자체 로직을 들고 있음.
*Stub* 미리 준비된 값을 출력하는 객체
*Mock* 메소드 호출을 확인하기위한 객체, 자가 검증 능력을 갖춤. 사실상 테스트 더블과 동일한 의미
*Spy* 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체

Dummy, Fake, Stub 정도는 제대로 구분할 줄 아는게 대화하는데에도 도움이 많이 됨.

## 의존성과 Testability

### 의존성

의존성: 다른 객체의 함수를 사용하는 상태
A는 B를 사용하기만 해도 의존한다고 볼 수 있다.

의존성 역전: 상위 모듈은 하위모듈에 의존해서는 안된다. 추상화에 의존해야함. 추상화는 세부사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야함.

테스트를 잘하려면 의존성 주입과 의존성 역전을 잘 다룰줄 알아야 한다.

만약 현재시간이 필요한 함수가 있다고 할때, ClockHolder라는 인터페이스를 의존받게 만든다.
테스트에 사용할 TestClockHolder와, 실제 사용할 SystemClockHolder를 각각 구현하여 사용한다.
의존성 주입 + 의존성 역전으로 해결! 모듈을 갈아끼우듯이 Port-Adapter라고도 불림.

대부분의 소프트웨어 문제는 의존성 역전으로 해결 가능하다.

### Testability

얼마나 쉽게 input을 변경하고, output을 쉽게 검증할 수 있는가?

감춰진 의존성
AuthTokenGetter 같은 interface를 만들어서,  create()의 파라미터에 authTokenGetter의 구현체도 받는다?

하드코딩
외부 시스템 연동

감춰진 결과

이렇게 4가지는 Testability가 낮다고 볼 수 있다. 어떻게 하면 올릴 수 있을까?

### 기타 조언

만약 private 메소드를 테스트하고 싶다는 느낌이 든다??
사실 private 메소드가 아니어야 하거나, 분리/책임 위임으로 public으로 만들라는 신호이다.

final 메소드를 stub하는 상황도 설계를 개선하라는 신호이다.

중복이 되더라도 반복이 되는게 낫다. DRY < DAMP

테스트 코드에 논리 로직 (for, if, + 등)을 추가하지 말자. 직관적인게 좋다.
